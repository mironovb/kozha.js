<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Educational Sign Language Translator (SiGML)</title>
  
  <!-- CWASA core (keep these URLs per their docs) -->
  <link rel="stylesheet" href="https://vhg.cmp.uea.ac.uk/tech/jas/vhg2024/cwa/cwasa.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script defer src="https://vhg.cmp.uea.ac.uk/tech/jas/vhg2024/cwa/allcsa.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>  <script defer src="https://cdn.jsdelivr.net/npm/@xenova/transformers@3.2.1/dist/transformers.min.js" crossorigin="anonymous"></script>
  <!-- Lightweight POS/NLP (compromise) for in-browser EDU pipeline -->
  <script defer src="https://unpkg.com/compromise@14.12.0/builds/compromise.min.js" crossorigin="anonymous"></script>

  <!-- ffmpeg.wasm (only used when a video file is uploaded) -->
  <script defer src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/ffmpeg.min.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --bg: #0b1020;
      --card: #0f162c;
      --muted: #97a2c2;
      --accent: #5b8cff;
      --accent-2: #22d3ee;
      --border: #1c2442;
      --radius: 18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; padding:24px; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: linear-gradient(180deg, #0b1020 0%, #0b1226 100%);
      color:white;
    }
    .container{max-width:1200px; margin:0 auto;}
    .title{font-weight:800; letter-spacing:-0.02em; font-size: clamp(24px, 5vw, 36px);}
    .subtle{color:var(--muted)}

    .grid{display:grid; gap:16px; grid-template-columns: 1fr;}
    @media (min-width: 980px){ .grid{ grid-template-columns: 480px 1fr; } }

    .card{background:var(--card); border:1px solid var(--border); border-radius:var(--radius); padding:16px;}
    .card h3{margin:0 0 12px; font-size: 16px; letter-spacing:0.02em; color:#c9d4ff}

    label{font-size:12px; text-transform:uppercase; letter-spacing:0.08em; color:#9fb0ff}
    input[type="text"], textarea, select{
      width:100%; background:#0c1326; color:white; border:1px solid #1b2550; border-radius:12px; padding:10px 12px; outline:none;
    }
    textarea{min-height:64px}

    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .grow{flex:1 1 auto}

    button{
      background: linear-gradient(90deg, var(--accent) 0%, var(--accent-2) 100%);
      border:none; color:white; padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:700;
    }
    button.secondary{background:#111a37; color:#d6defe; border:1px solid #1f2b5b}
    button:disabled{opacity:0.55; cursor:default}

    .chips{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px}
    .chip{background:#0c1326; border:1px solid #1b2550; color:#cdd7ff; border-radius:999px; padding:6px 10px; font-size:12px}

    .avatar-wrap{ background:#0a1124; border:1px solid #1b2550; border-radius:16px; padding:12px; display:inline-block }
    .CWASAAvatar.av0{ width: 448px; height: 360px; }

    .muted{ color:#a7b3de }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .log{ background:#0c1326; border:1px dashed #243163; padding:8px 10px; border-radius:10px; min-height: 40px; white-space: pre-wrap }

    .tabs{ display:flex; gap:6px; margin-bottom:8px }
    .tabs button{ background:#0f1836; border:1px solid #1c2859 }
    .tabs button.active{ background: linear-gradient(90deg, var(--accent) 0%, var(--accent-2) 100%); border:none }

    .kbd{padding:2px 6px; border-radius:6px; background:#0f1731; border:1px solid #1d2a5b; color:#c9d4ff; font-size:12px}

    .hint{font-size:12px; color:#8aa0ff}
  </style>
</head>
<body>
  <div class="container">
    <div style="margin-bottom:16px">
      <div class="title">Educational Sign Language Translator</div>
      <div class="subtle">Plan tokens from text or speech and render SiGML with CWASA</div>
    </div>

    <div class="grid">
        </div>

        <section>
  <div class="card">
    <h3>Text</h3>
    <div class="row">
      <textarea id="textIn" placeholder="Type a phrase…" class="grow"></textarea>
    </div>
    <div class="row" style="margin-top:8px">
      <label class="hint">Language hint (for STT only)</label>
      <select id="langHint">
        <option value="auto">auto</option>
        <option value="en" selected>en</option>
        <option value="ru">ru</option>
        <option value="es">es</option>
        <option value="de">de</option>
        <option value="fr">fr</option>
        <option value="zh">zh</option>
        <option value="ja">ja</option>
      </select>
      <span class="grow"></span>
      <label class="row" style="gap:6px; align-items:center">
        <input type="checkbox" id="useOpenAI" /> Use OpenAI planner
      </label>
      <button id="planBtn">Plan</button>
    </div>
  </div>

<!-- NEW: STEM / EDU tools -->
        <div class="card">
          <h3>STEM / EDU tools</h3>
          <div class="row" style="margin-bottom:8px">
            <label class="row" style="gap:6px; align-items:center"><input type="checkbox" id="eduNlpToggle" /> Use EDU NLP pipeline</label>
            <label class="row" style="gap:6px; align-items:center"><input type="checkbox" id="applyAbbrev" /> Apply abbreviations</label>
            <label class="row" style="gap:6px; align-items:center"><input type="checkbox" id="stemMode" /> STEM mode</label>
          </div>
          <div class="row" style="margin-bottom:8px">
            <label class="grow">Load abbreviations JSON (URL)</label>
            <input id="abbrevUrl" type="text" placeholder="abbreviations.json" />
            <button id="loadAbbrevUrlBtn">Load</button>
          </div>
          <div class="row">
            <label class="grow">Or upload JSON file</label>
            <input id="abbrevFile" type="file" accept="application/json" />
            <button id="clearAbbrevBtn" class="secondary">Clear</button>
          </div>
          <div class="hint" style="margin-top:6px">EDU NLP extracts pronouns, verb lemmas, and key nouns; abbreviations collapse multi-word forms (e.g., “carbon dioxide” → “co2”).</div>
        </div>

        <div class="card">
          <h3>Microphone</h3>
          <div class="row">
            <button id="recordBtn" class="secondary">● Start recording</button>
            <button id="transcribeBtn">Transcribe</button>
            <div id="micStatus" class="muted">Idle</div>
          </div>
          <textarea id="transcription" placeholder="Transcription will appear here" style="margin-top:8px"></textarea>
          <div class="hint" style="margin-top:6px">On-device Whisper (transformers.js). First run downloads model; allow ~100–200MB cache.</div>
        </div>

        <div class="card">
          <h3>Video Upload → Sign</h3>
          <input type="file" id="videoFile" accept="video/*" />
          <div class="row" style="margin-top:8px">
            <button id="videoToSignBtn">Video → Sign</button>
            <div id="videoStatus" class="muted">No file</div>
          </div>
        </div>

        <div class="card">
          <h3>Settings</h3>
          <div class="row">
            <label class="grow">OpenAI API key (optional, stored locally)</label>
            <input id="openaiKey" type="text" placeholder="sk-..." />
            <button id="saveKeyBtn" class="secondary">Save</button>
          </div>
          <div class="row" style="margin-top:8px">
            <label class="grow">Database .sigml URL(s)</label>
            <input id="dbUrlInput" type="text" placeholder="database/hamnosys_bsl_version1.sigml" />
            <button id="loadDbBtn">Load</button>
          </div>
          <div class="hint" style="margin-top:6px">You can load multiple files one-by-one. Loaded signs override earlier duplicates by gloss.</div>
        </div>
      </section>

      <!-- RIGHT: Outputs + CWASA -->
      <section>
        <div class="card">
          <h3>Planner</h3>
          <div class="row">
            <div class="grow">
              <label>Planner log</label>
              <div id="planLog" class="log"></div>
            </div>
          </div>
          <div class="row" style="margin-top:8px">
            <div class="grow">
              <label>Normalized</label>
              <input type="text" id="normalizedOut" readonly />
            </div>
            <div class="grow">
              <label>Tokens</label>
              <input type="text" id="tokensOut" readonly />
            </div>
          </div>
          <details style="margin-top:8px">
            <summary class="hint">Vocabulary (from database)</summary>
            <div id="allowedOut" class="mono" style="margin-top:8px; max-height:160px; overflow:auto"></div>
          <h3>EDU Diagnostics</h3>
          <div class="row">
            <div class="grow">
              <label>Timeframe guess</label>
              <input type="text" id="timeframeOut" readonly />
            </div>
            <div class="grow">
              <label>Abbreviations applied</label>
              <input type="text" id="abbrevCountOut" readonly />
            </div>
          </div>
        </div>

        <div class="card">
          <h3>Render (CWASA)</h3>
          <div class="row" style="align-items:flex-start">
            <div class="avatar-wrap">
              <div class="CWASAAvatar av0"></div>
            </div>
            <div class="grow">
              <div class="row" style="margin-bottom:8px">
                <button id="renderBtn">Play planned signs</button>
                <button id="stopBtn" class="secondary">Stop</button>
                <div id="renderStatus" class="muted">CWASA loading…</div>
              </div>
              <label>Queued tokens</label>
              <div id="queuedChips" class="chips"></div>
              <div class="hint" style="margin-top:6px">Renders by concatenating the matching <span class="kbd">&lt;hns_sign&gt;</span> blocks into one SiGML and sending to <span class="kbd">CWASA.playSiGMLText</span>.</div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>

// ------------------------------
// CWASA init
// ------------------------------
const renderStatus = document.getElementById('renderStatus');

function initCWASA() {
  if (!window.CWASA) {
    renderStatus.textContent = 'CWASA script not loaded. Check URLs.';
    return;
  }
  CWASA.init({
    useClientConfig: false,
    useCwaConfig: true,
    avSettings: [{
      width: 384,
      height: 320,
      avList: 'avs',
      initAv: 'anna',
      ambIdle: true,
      allowFrameSteps: false,
      allowSiGMLText: false,
    }]
  });
  if (CWASA.ready && typeof CWASA.ready.then === 'function') {
    CWASA.ready.then(() => { renderStatus.textContent = 'Ready.'; });
  } else {
    setTimeout(() => { renderStatus.textContent = 'Ready.'; }, 300);
  }
}
window.addEventListener('load', () => {
  setTimeout(() => {
    try { initCWASA(); } catch (e) {
      console.error(e);
      renderStatus.textContent = 'CWASA init error — see console.';
    }
  }, 150);
});
</script>
  <script>
    // ------------------------------
    // Abbreviations loading + EDU NLP helpers
    // ------------------------------
    const abbrevUrl = document.getElementById('abbrevUrl');
    const loadAbbrevUrlBtn = document.getElementById('loadAbbrevUrlBtn');
    const abbrevFile = document.getElementById('abbrevFile');
    const clearAbbrevBtn = document.getElementById('clearAbbrevBtn');
    const applyAbbrev = document.getElementById('applyAbbrev');
    const eduNlpToggle = document.getElementById('eduNlpToggle');
    const stemMode = document.getElementById('stemMode');
    const timeframeOut = document.getElementById('timeframeOut');
    const abbrevCountOut = document.getElementById('abbrevCountOut');

    // Abbrev store (phrase -> replacement)
    let ABBREV = new Map();

    // Optional: preload a minimal STEM set
    const STEM_PRESET = {
      'carbon dioxide': 'co2',
      'deoxyribonucleic acid': 'dna',
      'adenosine triphosphate': 'atp',
      'machine learning': 'ml',
      'artificial intelligence': 'ai',
      'central processing unit': 'cpu',
      'graphics processing unit': 'gpu',
    };

    function applyStemPreset(){
      for (const [k,v] of Object.entries(STEM_PRESET)) ABBREV.set(k.toLowerCase(), v.toLowerCase());
    }

    function clearAbbrev(){ ABBREV.clear(); updateAbbrevCount(0); log('Cleared abbreviations.'); }

    function updateAbbrevCount(n){ abbrevCountOut.value = String(n); }

    async function loadAbbrevFromUrl(url){
      try{
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const obj = await res.json();
        let n = 0;
        for (const [k,v] of Object.entries(obj||{})){
          ABBREV.set(String(k).toLowerCase().trim(), String(v).toLowerCase().trim());
          n++;
        }
        updateAbbrevCount(ABBREV.size);
        log(`Loaded ${n} abbreviations from ${url}`);
      }catch(e){ log('Abbrev load error: ' + e); }
    }

    async function loadAbbrevFromFile(file){
      try{
        const txt = await file.text();
        const obj = JSON.parse(txt);
        let n = 0;
        for (const [k,v] of Object.entries(obj||{})){
          ABBREV.set(String(k).toLowerCase().trim(), String(v).toLowerCase().trim());
          n++;
        }
        updateAbbrevCount(ABBREV.size);
        log(`Loaded ${n} abbreviations from file: ${file.name}`);
      }catch(e){ log('Abbrev file error: ' + e); }
    }

    // Word-boundary-safe replacement + acronym casing
    function replaceAbbreviationsBrowser(text){
      if (!applyAbbrev.checked || ABBREV.size === 0) return { text, count: 0 };
      const pairs = Array.from(ABBREV.entries()).sort((a,b)=> b[0].length - a[0].length);
      let count = 0; let out = text;
      for (const [phrase, replRaw] of pairs){
        const escaped = phrase.replace(/[.*+?^${}()|[\]\]/g,'\$&');
        const re = new RegExp(`(?<!\w)${escaped}(?!\w)`, 'gi');
        const replacer = (m)=>{ count++; const repl = String(replRaw);
          if (/^[a-z]{2,5}$/.test(repl)) return repl.toUpperCase();
          return repl; };
        out = out.replace(re, replacer);
      }
      return { text: out, count };
    }

    // EDU NLP using compromise: pronouns, verb lemmas, key nouns
    const EDU_STOPWORDS = new Set(['a','an','the','and','or','but','if','then','than','of','to','in','on','at','for','from','with','as','by','is','are','am','be','been','was','were','do','does','did','that','this','those','these','it','my','your','our']);

    function timeframeGuess(str){
      const s = str.toLowerCase();
      if (/will|tomorrow|next/.test(s)) return 'In the future';
      if (/yesterday|ago|last/.test(s)) return 'In the past';
      return 'Now';
    }

    function processEducationalText(text){
      const doc = window.nlp(text);
      const tokens = [];
      const pronouns = doc.match('#Pronoun').out('array').map(s=>s.toLowerCase());
      for (const p of pronouns){ if (!EDU_STOPWORDS.has(p)) tokens.push(p); }
      const verbInf = doc.verbs().toInfinitive().out('array').map(s=>s.toLowerCase());
      for (const v of verbInf){ if (!EDU_STOPWORDS.has(v)) tokens.push(v); }
      const nouns = doc.nouns().toSingular().out('array').map(s=>s.toLowerCase());
      for (const n of nouns){ if (!EDU_STOPWORDS.has(n)) tokens.push(n); }
      const seen = new Set();
      const uniq = tokens.filter(t=>{ if (seen.has(t)) return false; seen.add(t); return true; });
      return uniq;
    }

    // UI wiring
    loadAbbrevUrlBtn.addEventListener('click', ()=>{ const u = abbrevUrl.value.trim(); if (u) loadAbbrevFromUrl(u); });
    abbrevFile?.addEventListener('change', (e)=>{ const f = e.target.files?.[0]; if (f) loadAbbrevFromFile(f); });
    clearAbbrevBtn.addEventListener('click', ()=> clearAbbrev());
    stemMode.addEventListener('change', ()=>{ if (stemMode.checked){ applyStemPreset(); updateAbbrevCount(ABBREV.size); log('STEM preset loaded.'); } });
  </script>
  <script>
    // ------------------------------
    // Database loading (SiGML) & vocab
    // ------------------------------
    const allowedOut = document.getElementById('allowedOut');
    const dbUrlInput = document.getElementById('dbUrlInput');
    const loadDbBtn = document.getElementById('loadDbBtn');

    const glossToSign = new Map(); // gloss -> <hns_sign>...</hns_sign>

    async function loadSigmlUrl(url){
      try{
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const xmlText = await res.text();
        const doc = new DOMParser().parseFromString(xmlText, 'application/xml');
        const signs = Array.from(doc.querySelectorAll('hns_sign'));
        let added = 0;
        for (const s of signs){
          const gloss = (s.getAttribute('gloss') || '').trim().toLowerCase();
          if (!gloss) continue;
          glossToSign.set(gloss, s.outerHTML);
          added++;
        }
        refreshAllowedOutput();
        log(`Loaded ${added} signs from ${url}`);
      }catch(e){
        log(`Failed to load ${url}: ${e}. If this is a CORS error, host the file under /database on the same origin or enable CORS on the source.`);
      }
    }

    function refreshAllowedOutput(){
      const list = Array.from(glossToSign.keys()).sort();
      allowedOut.textContent = list.join(', ');
    }

    loadDbBtn.addEventListener('click', () => {
      const u = dbUrlInput.value.trim();
      if (u) loadSigmlUrl(u);
    });

    // Auto-load default DB path
    if (dbUrlInput){ dbUrlInput.value = 'database/hamnosys_bsl_version1.sigml'; loadSigmlUrl(dbUrlInput.value); }
  </script>

  <script>
    // ------------------------------
    // Planning pipeline (normalize → heuristic → fuzzy map) (normalize → heuristic → fuzzy map)
    // ------------------------------
    const textIn = document.getElementById('textIn');
    const planBtn = document.getElementById('planBtn');
    const planLog = document.getElementById('planLog');
    const normalizedOut = document.getElementById('normalizedOut');
    const tokensOut = document.getElementById('tokensOut');
    const queuedChips = document.getElementById('queuedChips');
    const useOpenAI = document.getElementById('useOpenAI');

    const STOPWORDS = new Set(['a','an','the','and','or','but','if','then','than','of','to','in','on','at','for','from','with','as','by','is','are','am','be','been','was','were','do','does','did','that','this','those','these','it','my','your','our']);
    const TOPIC_TIME = new Set(['today','yesterday','tomorrow','morning','afternoon','evening','night','noon','week','month','year','time']);

    function normalizeText(str){
      return (str||'').toLowerCase().replace(/[\p{P}\p{S}]/gu,' ').split(/\s+/).filter(Boolean);
    }

    function heuristicPlan(tokens){
      const kept = tokens.filter(t => !STOPWORDS.has(t));
      const front = kept.filter(t => TOPIC_TIME.has(t));
      const rest = kept.filter(t => !TOPIC_TIME.has(t));
      return [...front, ...rest];
    }

    // Simple Levenshtein distance + similarity ratio
    function levenshtein(a,b){
      const m=a.length, n=b.length; if(!m) return n; if(!n) return m;
      const dp = new Array(n+1); for(let j=0;j<=n;j++) dp[j]=j;
      for(let i=1;i<=m;i++){
        let prev = dp[0]; dp[0]=i;
        for(let j=1;j<=n;j++){
          const temp = dp[j];
          dp[j] = Math.min(
            dp[j] + 1,
            dp[j-1] + 1,
            prev + (a[i-1]===b[j-1]?0:1)
          );
          prev = temp;
        }
      }
      return dp[n];
    }
    function similarity(a,b){
      if (!a||!b) return 0;
      const d = levenshtein(a,b);
      return 1 - d / Math.max(a.length, b.length);
    }

    function mapToAvailable(tokens, allowed, cutoff = 0.85){
      const mapped = [], subs = {}, missing = [];
      if (allowed.length === 0) return { mapped, subs, missing: [...tokens] };
      for (const t of tokens){
        if (allowed.includes(t)) { mapped.push(t); continue; }
        let best=null, bestScore=0;
        for (const a of allowed){
          const s = similarity(t, a);
          if (s > bestScore) { bestScore = s; best = a; }
        }
        if (best && bestScore >= cutoff){
          mapped.push(best);
          subs[t] = best;
        } else {
          missing.push(t);
        }
      }
      return { mapped, subs, missing };
    }

    function currentAllowed(){
      return Array.from(glossToSign.keys()).sort();
    }

    function chipify(tokens){
      queuedChips.innerHTML = '';
      for (const t of tokens){
        const div = document.createElement('div');
        div.className = 'chip';
        div.textContent = t;
        queuedChips.appendChild(div);
      }
    }

    // Optional OpenAI planner
    async function planWithOpenAI(rawText, allowed){
      const key = localStorage.getItem('openai_key');
      if (!key) return null;
      const system = "You rewrite user sentences into ASL-friendly word order as tokens. Use ONLY words from the allowed vocabulary provided. If a word is not present, substitute the closest semantic match from the allowed list. Return ONLY the final token sequence as a single space-separated line. No explanations.";
      const user = `ALLOWED:\n${allowed.join(', ')}\n\nTEXT:\n${rawText}\n\nFORMAT:\nspace-separated tokens, lowercase`;
      try{
        const resp = await fetch('https://api.openai.com/v1/chat/completions',{
          method:'POST',
          headers:{ 'Authorization': `Bearer ${key}`, 'Content-Type':'application/json' },
          body: JSON.stringify({
            model:'gpt-4o-mini',
            temperature:0.1,
            messages:[{role:'system', content:system},{role:'user', content:user}],
          })
        });
        if (!resp.ok) throw new Error('OpenAI HTTP ' + resp.status);
        const data = await resp.json();
        const content = (data.choices?.[0]?.message?.content || '').trim();
        const toks = content.split(/\s+/).filter(w => allowed.includes(w));
        return toks.length ? toks : null;
      }catch(e){ log('OpenAI planner error: ' + e); return null; }
    }

    async function doPlan(){
      const raw0 = textIn.value.trim();
      if (!raw0) { log('Empty text.'); return; }
      const allowed = currentAllowed();
      if (allowed.length === 0){ log('database/ is empty — add .sigml files first.'); return; }

      // Abbreviations (optional)
      const { text: raw, count: abCount } = replaceAbbreviationsBrowser(raw0);
      if (typeof abbrevCountOut !== 'undefined') abbrevCountOut.value = String(abCount);
      if (typeof timeframeOut !== 'undefined') timeframeOut.value = timeframeGuess(raw);

      let mapped = null, subs={}, missing=[];

      // EDU NLP pipeline (optional)
      if (typeof eduNlpToggle !== 'undefined' && eduNlpToggle.checked){
        const eduTokens = processEducationalText(raw);
        const m = mapToAvailable(eduTokens, allowed, 0.85);
        mapped = m.mapped; subs = m.subs; missing = m.missing;
        normalizedOut.value = eduTokens.join(' ');
        const lines = [];
        lines.push('edu-nlp');
        if (Object.keys(subs).length) lines.push('substitutions: ' + JSON.stringify(subs));
        if (missing.length) lines.push('missing: ' + missing.join(', '));
        planLog.textContent = lines.join('
');
      }

      // OpenAI planner (optional)
      if (!mapped && useOpenAI && useOpenAI.checked){
        const toks = await planWithOpenAI(raw, allowed);
        if (toks){
          mapped = toks;
          normalizedOut.value = normalizeText(raw).join(' ');
          planLog.textContent = 'planned (OpenAI)';
        }
      }

      // Heuristic fallback
      if (!mapped){
        const norm = normalizeText(raw);
        const heur = heuristicPlan(norm);
        const m = mapToAvailable(heur, allowed, 0.85);
        mapped = m.mapped; subs = m.subs; missing = m.missing;
        normalizedOut.value = norm.join(' ');
        const lines = [];
        if (heur.length) lines.push('heuristic: ' + heur.join(' '));
        if (Object.keys(subs).length) lines.push('substitutions: ' + JSON.stringify(subs));
        if (missing.length) lines.push('missing: ' + missing.join(', '));
        planLog.textContent = lines.length ? lines.join('
') : 'planned';
      }

      tokensOut.value = mapped.join(' ');
      chipify(mapped);
      window.__plannedTokens = mapped;
    planBtn.addEventListener('click', doPlan);
  </script>

  <script>
    // ------------------------------
    // Render with CWASA (concatenate SiGML blocks for planned tokens)
    // ------------------------------
    const renderBtn = document.getElementById('renderBtn');
    const stopBtn = document.getElementById('stopBtn');

    function buildSigml(tokens){
      const blocks = [];
      for (const t of tokens){
        const b = glossToSign.get(t);
        if (b) blocks.push(b);
      }
      if (!blocks.length) return null;
      return `<?xml version="1.0" encoding="utf-8"?>\n<sigml>\n${blocks.join('\n')}\n</sigml>`;
    }

    function playSigml(sigml){
      try{
        CWASA.playSiGMLText(sigml, 0);
      }catch(e){ log('CWASA play error: ' + e); }
    }

    renderBtn.addEventListener('click', () => {
      const toks = window.__plannedTokens || [];
      if (!toks.length){ log('Nothing to render — token list is empty.'); return; }
      const sigml = buildSigml(toks);
      if (!sigml){ log('No matching signs for planned tokens.'); return; }
      playSigml(sigml);
    });

    stopBtn.addEventListener('click', () => {
      try{ CWASA.stop(0); }catch(_e){}
    });
  </script>

  <script>
    // ------------------------------
    // Microphone recording + on-device Whisper (transformers.js)
    // ------------------------------
    const recordBtn = document.getElementById('recordBtn');
    const transcribeBtn = document.getElementById('transcribeBtn');
    const micStatus = document.getElementById('micStatus');
    const transcription = document.getElementById('transcription');
    const langHint = document.getElementById('langHint');

    let mediaRecorder = null;
    let recordedChunks = [];

    function pickAsrModel(){
      const ua = navigator.userAgent || '';
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(ua);
      return isMobile ? 'Xenova/whisper-tiny.en' : 'Xenova/whisper-small';
    }

    async function ensureASR(){
      const { pipeline } = window.transformers;
      const model = pickAsrModel();
      if (!window.__asr || window.__asrModelName !== model){
        window.__asr = await pipeline('automatic-speech-recognition', model);
        window.__asrModelName = model;
      }
      return window.__asr;
    }
recordBtn.addEventListener('click', async () => {
      if (!mediaRecorder){
        // start
        try{
          const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
          recordedChunks = [];
          mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          mediaRecorder.ondataavailable = (e)=>{ if(e.data.size>0) recordedChunks.push(e.data); };
          mediaRecorder.onstop = ()=>{ stream.getTracks().forEach(t=>t.stop()); };
          mediaRecorder.start();
          recordBtn.textContent = '■ Stop recording';
          recordBtn.classList.remove('secondary');
          micStatus.textContent = 'Recording…';
        }catch(e){ micStatus.textContent = 'Mic error: ' + e; }
      } else {
        // stop
        mediaRecorder.stop();
        mediaRecorder = null;
        recordBtn.textContent = '● Start recording';
        recordBtn.classList.add('secondary');
        micStatus.textContent = `Recorded ${(recordedChunks.reduce((s,b)=>s+b.size,0)/1024/1024).toFixed(1)} MB`;
      }
    });

    transcribeBtn.addEventListener('click', async () => {
      if (!recordedChunks.length){ micStatus.textContent = 'Nothing recorded.'; return; }
      micStatus.textContent = 'Loading ASR model… (first time can take a while)';
      try{
        const asr = await ensureASR();
        micStatus.textContent = 'Transcribing…';
        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        const result = await asr(blob, { chunk_length_s: 30, stride_length_s: 5 });
        transcription.value = (result?.text || '').trim();
        micStatus.textContent = 'Done.';
      }catch(e){ micStatus.textContent = 'Transcription error: ' + e; }
    });
  </script>

  <script>
    // ------------------------------
    // Video → Sign: extract audio with ffmpeg.wasm → Whisper ASR → plan → render
    // ------------------------------
    const videoFile = document.getElementById('videoFile');
    const videoToSignBtn = document.getElementById('videoToSignBtn');
    const videoStatus = document.getElementById('videoStatus');

    async function ensureFFmpeg(){
      if (!window.__ffmpeg){
        const { createFFmpeg, fetchFile } = FFmpeg;
        const ffmpeg = createFFmpeg({ log: false });
        await ffmpeg.load();
        window.__ffmpeg = { ffmpeg, fetchFile };
      }
      return window.__ffmpeg;
    }

    videoToSignBtn.addEventListener('click', async () => {
      const file = videoFile.files?.[0];
      if (!file){ videoStatus.textContent = 'Choose a video first.'; return; }
      try{
        videoStatus.textContent = 'Preparing ffmpeg…';
        const { ffmpeg, fetchFile } = await ensureFFmpeg();
        videoStatus.textContent = 'Extracting audio…';
        ffmpeg.FS('writeFile', 'in', await fetchFile(file));
        // extract mono 16k WAV — what Whisper likes
        await ffmpeg.run('-i', 'in', '-vn', '-ac', '1', '-ar', '16000', '-f', 'wav', 'out.wav');
        const data = ffmpeg.FS('readFile', 'out.wav');
        const wavBlob = new Blob([data.buffer], { type: 'audio/wav' });

        videoStatus.textContent = 'Loading ASR model…';
        const asr = await ensureASR();
        videoStatus.textContent = 'Transcribing…';
        const result = await asr(wavBlob, { chunk_length_s: 30, stride_length_s: 5 });
        const text = (result?.text || '').trim();
        transcription.value = text;
        videoStatus.textContent = 'Planning…';
        textIn.value = text;
        await doPlan();
        videoStatus.textContent = 'Ready to render.';
      }catch(e){ videoStatus.textContent = 'Video→Sign error: ' + e; }
    });
  </script>

  <script>
    // ------------------------------
    // Settings (OpenAI key)
    // ------------------------------
    const openaiKey = document.getElementById('openaiKey');
    const saveKeyBtn = document.getElementById('saveKeyBtn');

    openaiKey.value = localStorage.getItem('openai_key') || '';
    saveKeyBtn.addEventListener('click', () => {
      const v = openaiKey.value.trim();
      if (v){ localStorage.setItem('openai_key', v); log('Saved OpenAI key locally.'); }
      else { localStorage.removeItem('openai_key'); log('Cleared OpenAI key.'); }
    });
  </script>

  <script>
    // ------------------------------
    // Logger helper
    // ------------------------------
    function log(msg){
      const el = document.getElementById('planLog');
      const now = new Date().toLocaleTimeString();
      const prev = el.textContent ? (el.textContent + '\n') : '';
      el.textContent = prev + `[${now}] ${msg}`;
    }
  </script>
</body>
</html>
